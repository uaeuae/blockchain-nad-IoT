pragma solidity ^0.4.15;

//Smart Contract thats controlled by Manufacture used to generate New IoT devices ownership smart contracts
contract Factory {			
    address[] public iotDevices; // list of IOT devices public addresses generated by the Manufacture
	address factoryOwner; 

    modifier onlyOwner{ //prerequisite 
	require(msg.sender == factoryOwner); 
	_; 
	}
	
    event addNewIot(string _productName, address _name, address _value); //record new IOT devices 
	
	function Factory(){ //constructor 
		factoryOwner = msg.sender; 
	}
	
	//Function controlled by manufacture
    function createIotContract (string _productName, string _description, string _specification, string _serialNumber) onlyOwner returns (address){ 
        address newDevice = new IotCreation(factoryOwner,  _productName,  _description,  _specification,  _serialNumber, false); // smart contract for IoT device  generation 
        iotDevices.push(newDevice); 
        addNewIot(_productName, msg.sender,newDevice); //log the changes 
        return newDevice; 
    } 
    
}

//Smart Contract thats owned by the owner of IoT devices 
contract IotCreation{ //IOT Device contracts
	//address public owner; //IOT Device owner public address
	mapping (uint => address) public owner; 
	address public hospital; 
	string public productName; 
	string public description;  
	string[] public specification; 
	string public serialNumber; 
	bool public mutliOwner;
	uint public nextOwnerId;
	
	event addNewOwner(string _msg, address newOwner);
	
	function IotCreation(address _owner, string _productName, string _description, string _specification, string _serialNumber, bool _mutliOwner){
		nextOwnerId = 0;
		owner [nextOwnerId] = _owner; // maintain IOT device owner public address
		hospital = _owner;
		productName = _productName;
		description = _description;
		specification.push(_specification); 
        serialNumber = _serialNumber; 
		mutliOwner = _mutliOwner;		
		addNewOwner ('Device has been created', owner[0]);// keep history of IOT device Owners
		nextOwnerId ++;

	}
	
	modifier ifOwner(){//prerequisite 
		//require(msg.sender == owner[0]); //condition that been require
		for (uint i = 0; i < nextOwnerId; i++){
			if(msg.sender == owner[i]){
				i = nextOwnerId;
				_;			
				} 
			}
	}
	modifier ifhospital(){//prerequisite for ownership revoktion
		require(msg.sender == hospital); 
		_;
		
	}	
	
		//Function controlled by IoT device owner	
	function ownershipTransfer(address [] newOwner, bool _mutliOwner) ifOwner {
		for (uint i = 0; i < newOwner.length; i++ ){
			owner[i] = newOwner [i];
		}
		nextOwnerId = newOwner.length;
		mutliOwner = _mutliOwner;
		
	}
	
	
	function productNameUpdate(string newProductName) ifOwner{
		productName = newProductName; 
		
	}
	
	function specificationUpdate(string newSpecification) ifOwner{
		specification.push(newSpecification);
		
	}
	
	//Function controlled by owner
	function deviceDecommissioning() ifOwner{
		for (uint i = 0; i < nextOwnerId; i++ ){
		owner[i] = 0; // there is no way to revert back
		}
		nextOwnerId = 0;
		addNewOwner ('Device has been decommissioned', owner[0]);
	}
	
	//Function controlled by hospital
	function deviceRevokation() ifhospital{
		owner [0] = hospital;
		for (uint i = 1; i < nextOwnerId; i++){
			owner [i] = 0;
		}
		addNewOwner ('Ownership has been revoked', owner[0]);
	}	
	
}